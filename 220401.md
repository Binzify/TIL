# 220401

### 👨🏼‍🏫과정 후기와 느낀점

#### 그래프

- 인접 행렬

  - ````python
    ```
    마지막 정점 번호, 간선수
    6, 8
    0 1 0 2 0 5 0 6 5 3 4 3 5 4 6 4
    ```
    
    V, E = map(int,input().split())
    arr = list(map(int,input().split()))
    adjM = [[0]*(V+1) for _ in range(V+1)]  # 인접행렬
    
    for i in range(E):
        n1, n2 = arr[i*2], arr[i*2+1]
        adjM[n1][n2] = 1  # n1과 n2 는 연결되어 있어
        adjM[n2][n1] = 1  # n2 와 n1 은 연결되어 있어  방향이 없으므로
        
    # 결과
    [[0, 1, 1, 0, 0, 1, 1],
    [1, 0, 0, 0, 0, 0, 0],
    [1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 1, 0],
    [0, 0, 0, 1, 0, 1, 1],
    [1, 0, 0, 1, 1, 0, 0],
    [1, 0, 0, 0, 1, 0, 0]]
    ````

  - 용도에 따라 그래프 저장 방식 선택

- 인접 리스트

  - ```python
    V, E = map(int,input().split())
    arr = list(map(int,input().split()))
    adjL = [[] for _ in range(V+1)]  # 인접 리스트 각 행은 비어있는 상태로 0번부터 V번까지 만들기
    
    for i in range(E):
        n1, n2 = arr[i*2], arr[i*2+1]
        adjL[n1].append(n2)
        adjL[n2].append(n1)  # 무향 그래프인 경우
    
    print(adjL)
    
    # 결과
    [[1, 2, 5, 6], [0], [0], [5, 4], [3, 5, 6], [0, 3, 4], [0, 4]]
    ```

  - 1000개가 넘어간다 ? 인접 리스트 생각해보기

- 그래프 탐색(순회)

  - 그래프 순회는 비선형구조인 그래프로 표현된 모든 자료를 빠짐없이 탐색하는 것을 의미
  - DFS, BFS 두 가지가 있다.
  - 스택(후입선출)과 큐(선입선출) 사용

- DFS 알고리즘 - 재귀

  - ```python
    DFS_Recursive(G, v)
    	visited [v] <- True # 방문 설정
        
        for each all w in adjacency (G, v)
        	if visited[w] != True
            	DFS_Recursive(G, w)
    ```

  - ```python
    # 1번째 dfs - 인접 행렬
    def dfs1(v):
        visited[v] = 1
        print(v, end = ' ')
        for w in range(V+1):  # i 에 인적합 모든 노드에 대해
            # 인접 행렬을 쓰는 경우
            if adjM[v][w] and visited[w] == 0:  # 연결되어 있고 아직 방문하지 않은 곳이라면
                dfs1(w)
    
    # 2번째 dfs - 인접 리스트
    def dfs2(v):
        visited[v] = 1
        print(v, end = ' ')
        for w in adjL[v]: # v에 인접한 모든 노드 w에 대해 (인접리스트 사용)
            if visited[w] == 0:
                dfs2(w)
    
    V, E = map(int,input().split())  # V 마지막 정점번호 E 간선 수
    arr = list(map(int,input().split()))
    adjM = [[0]*(V+1) for _ in range(V+1)]  # 인접행렬
    adjL = [[] for _ in range(V+1)]  # 인접 리스트 각 행은 비어있는 상태로 0번부터 V번까지 만들기
    
    for i in range(E):
        n1, n2 = arr[i*2], arr[i*2+1]
        adjM[n1][n2] = 1  # n1과 n2 는 연결되어 있어
        adjM[n2][n1] = 1  # n2 와 n1 은 연결되어 있어 (무향 그래프인 경우)
    
    
    for i in range(E):
        n1, n2 = arr[i*2], arr[i*2+1]
        adjL[n1].append(n2)
        adjL[n2].append(n1)  # 무향 그래프인 경우
    
    visited = [0]*(V+1)
    #dfs1(0)
    dfs2(0)
    
    # 결과
    6 8
    0 1 0 2 0 5 0 6 5 3 4 3 5 4 6 4
    >> 0 1 2 5 3 4 6 
    ```

  - 방향 그래프라면, 그래프 생성 시 두번째 n2.append(n1) 부분을 지우면 된다.

  - ```python
    # 스택 방식 슈도코드
    stack = s
    visited[]
    DFS(s)
    	push(s,v)
        visited[v] = True
        while not isEmpty(s)
        	v <- pop(s)
            visit(v)
            for each w in adjaceny(v)
            	if not visited[w]
                	push(s,w)
                    visited[v] = True
    ```

- BFS

  - front, rear 구현 방식으로 사용하면 빠르게 작동 가능

  - ```python
    BFS(G,v) // 그래프 G, 탐색 시작점 v
    	큐 생성
        시작점 v를 큐에 삽입
        점 v를 방문하는 것으로 표시
        while 큐가 비어있지 않은 경우
        	t <- 큐의 첫번째 원소 반환
            for t와 연결된 모든 선에 대해
            	u <- t의 이웃점
                u가 방문되지 않은 곳이면,
                u를 큐에 넣고, 방문한 것으로 표시
    ```

- 서로소 집합 = 상호배타 집합

  -  서로 중복 포함된 원소가 없는 집합들 = 교집합이 없다
  - 집합에 속한 하나의 특정 멤버를 통해 각 집합들을 구분한다. 이를 `대표자`라 한다.
  - rep라는 대표 리스트를 만들고 구현

- MST 구현을 위한 알고리즘

  - Prim
  - Kruskal
  - Dijkstra (가장 중요한 알고리즘으로 꼭 이해하기 많이 나옴 코테에)

열심히 공부해야 할 듯.... 복습 필요



#### 웹엑스

- 만우절 기념 부울경 2반 헤일리 교수님과 스위치
  - 새로운 교수님을 만나고 부울경 사람들도 만날 수 있어서 좋았다.
- 배민 컨퍼런스





---

### 💁🏼‍♂️가장 기억에 남는 교육 내용

- 역삼역 던킨의 그분.... 
- 준호 교수님의 행복한 모습... 6반에서는 본 적 없다..
- 과목평가 - 서술형 : 트리 / 힙

---

### 💫부족한 부분과 개선방향

- 알고리즘 공부 다시하기
  - 시험 범위... 과목평가 준비
  - DFS 취약하므로 DFS 문제 많이 풀어보기
  - 오늘 배운 MST에 대한 내용 꼭 공부하기

