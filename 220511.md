# 220511

### 👨🏼‍🏫STUDY TODAY

#### 백준

- 어벤져스 엔드게임
  - Avengers: Endgame을 정답으로 출력하면 된다.
  - 처음엔 입력값 받고 출력에 문제의 답을 출력한다. 써져있길래 그 문장을 출력했더니 틀렸다. 알고보니 문제에서 어벤져드 엔드게임의 영문 제목을 출력하라고...ㅡㅡ;



#### 유튜브 & 웹엑스

- 중앙 집중식 저장소 역할

  State = data : 애플리케이션의 핵심이 되는 요소

  ### 상태 관리 패턴

  공유된 상태를 추출하고 이를 전역에서 관리하도록 한다.  ⇒ 중앙에서 집중하여 관리한다.

  기존 Pass props & Emit event

  각 컴포넌트는 독립적이라서 한 곳에서 filter를 지정하면 이를 받는 자식도 filter를 따로 지정해주어야 한다.

  데이터는 단방향 흐름으로 부모 → 자식 간의 전달만 가능하여 반대의 경우에는 이벤트를 트리거

  장점 : 데이터의 흐름을 직관적으로 파악 가능

  단점 : 컴포넌트 중첩이 깊어지는 경우 동위 관계의 컴포넌트로의 데이터 전달이 불편해짐

  → 같은 자식 컴포넌트끼리 정보를 전달하려면 부모를 거쳐서 전달해야 한다. 에밋 후 프롭

  공통상태를 공유하는 여러 컴포넌트가 있는 경우 데이터 전달 구조가 매우 복잡해진다.

  state는 data 고 action은 methods이다.

  view 는 HTML화면인데, state(data)의 선언적 매핑이다.

  ------

  ### Vuex (store) management pattern

  중앙 저장소에 state를 모아놓고 관리

  규모가 큰 (컴포넌트 중첩이 깊은) 프로젝트에서 매우 효율적

  각 컴포넌트에서는 중앙 집중 저장소의 state만 신경쓰면 됨

  동일한 data를 공유하는 다른 컴포넌트들도 동기화 된다.

  단방향 흐름에 의존한 상태(state)관리가 아닌 Vuex를 활용

  상태 흐름 관리가 매우 중요해졌고, 이러한 상태를 `올바르게 관리하는 저장소`의 필요성을 느끼게 됨

  상태의 변화는 오로지 Vuex가 관리, 반응하게 하자.

  다른 컴포넌트는 신경쓰지 않고 오로지 상태의 변화를 알림 (이메일/게시판만 열심히 보자)

  ------

  ### Vuex 핵심 컨셉

  사용자가 화면에서(Vue components) 클릭을 하면 어떠한 함수를 부르게 되는데(Action)

  Mutations이 데이터의 변경(Mutate)을 진행하여 state에 영향을 준다. 이는 또 화면에 변경된 상태를 보여준다(Render).

  Vuex는 Action (행동) ⇒ Mutations (변화) ⇒ State (데이터의 변화) 를 관리한다.

  ### State (data)

  중앙에서 관리하는 모든 상태 정보

  Vuex는 single state tree를 사용한다. 즉, 단일 객체는 모든 애플리케이션 상태를 포함하는 `원본 소스`()의 역할을 한다.

  이는 각 애플리케이션마다 하나의 저장소만 갖게 된다는 것을 의미한다.

  각 컴포넌트는 Vuex Store에서 State를 가져와 사용하게 됨

  ### Mutations

  실제 state를 변경하는 유일한 방법이고 위험한 작업이다.

  mutation의 handler 함수는 반드시 `동기적`이어야 한다.

  비동기적 로직(콜백함수 등)은 state가 변화하는 시점이 의도한 것과 달라질 수 있으며

  콜백이 실제로 호출 될 시기를 알 수 있는 방법이 없다 (추적할 수 없다)

  첫번째 인자로 항상 state를 받는다.

  Actions에서 commit() 메서드에 의해 호출된다.

  ### Action

  Mutations와 유사하지만, 차이가 존재한다.

  1. state를 변경하는 대신 mutations를 commit() 메서드로 호출해서 실행
  2. 비동기 작업이 포함될 수 있음 (백엔드 API와 통신하여 Data Fetching 등의 작업 수행)

  comtext 객체 인자를 받는다. context 객체를 통해 store/index.js 파일 내에 있는 모든 요소의 속성 접근과 메서드 호출이 가능하다. ⇒ state를 직접 변경하지 않는다.

  컴포넌트에서 dispatch() 메서드에 의해 호출됨

  ### State를 조작하고 관리하는 명확한 역할 분담 (Mutations와 Action)

  ### Getters

  store의 상태를 기반하는 계산 값

  실제 상태를 변경하지 않는다.

  computed 속성과 유사하다.

  중요한 비즈니스 로직이다. 이제 vuex에서 작성한 내용을 script에서 받아오므로 컴포넌트에 직접 script를 작성하는 일이 줄어들 것이다.

  MVVM

  우리는 시작할 때 모델링이 중요한데, 여기서 M(data)와 VM(컴포넌트 트리)가 중요하다.

  vuex에 사용한다고 해서 Vuex Store에 모든 상태를 넣어야 하는 것은 아니다.

- 내용 어려워서 중간에 듣다가 포기함



#### 보충

- workshop04 TodoList 구상하기
  - 트리구조 생각하며 짜기
- 필수적인 오늘 수업 보충
- TodoList 삭제까지 구현



#### 최종 프로젝트 회의

- 노션에 정리

---

### 💆🏼‍♂️REMEMBER

##### 없다...

---

### 💫SUPPLEMENT POINT

#### 뷰

- 매일 같은 이유
