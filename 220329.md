# 220329

### 👨🏼‍🏫과정 후기와 느낀점

- 카카오 프로그래머스

  - 실패율

    - 정말 간단하게 푸는 방식

    - ```python
      def solution(N, stages):
          answer = []
          fail_rate = {}  # 실패율 결과 담을 딕셔너리
          clear = len(stages)  # 스테이지에 도달한 플레이어 수
      
          for i in range(1, N+1):
              if clear != 0:  # 스테이지 도달한 사람 수가 존재한다면
                  remain = stages.count(i)  # 해당 숫자가 리스트에 몇 개 있는지 세기
                  fail_rate[i] = (remain/clear)  # 남은 유저 / 스테이지에 도달한 플레이어 수
              else: 
                  fail_rate[i] = 0
              clear = clear - remain  # 최종 스테이지 깬 길이에서 이미 값을 구한 사람들의 수 빼기
      
          # 최종 정답을 위해 튜플로 실패율을 만들고 비교한 뒤 정렬
          # [(3, 0.5), (4, 0.5), (2, 0.42857142857142855), (1, 0.125), (5, 0.0)]
          result = sorted(fail_rate.items(), key=lambda x: x[1], reverse=True)
      
          # 최종 튜플 중 인덱스만 최종 정답에 더하기
          for x, y in result:
              answer.append(x)
      
          return answer
      ```

    - 딕셔너리를 하나만 만들어두어도 된다. 초반 값을 바로 받아서 길이를 지정해 준 다음에 계속 빼주는 형태로 진행하면 된다.

    - 이 문제를 통해서 다른 방식도 돌려봐야 겠다는 것을 느꼈고 또 실행시간이 길면 코드를 다 지우고 새로 짜봐야겠다고 생각이 들었다.




- 웹엑스 문제풀이

  - 전자카트

    - 순열을 활용하여 방문하는 곳의 넘버를 출력하는 방식 같은데 이를 어떻게 풀어내야할 지 모르겠다
    - 알고보니 난 바보였다. 2차원 배열을 순회해야하는데 그대로 인덱스 값만 입력해서 순회를 하지 못해서 정답이 이상하게 나왔고 또 인덱스 변환할 때 어렵게 생각했는데, 돌아가는 순서를 생각해보면 0에서 출발하고 이미 거친 인덱스를 그 뒤에 인덱스 값으로 대치시켜준다는 것을 이해하고 문제를 풀자.

  - 최소합

    - dfs로 가야할 곳을 탐색하면서 값을 더해주고 그 최종 끝 지점의 도달값이 최소라면 결과값과 교환하기
    - 처음에 왼쪽도 가능한 줄 알고 손코딩했다가 나중에 우측과 하단으로만 갈 수 있다는 조건을 보고 변경
    - 조건을 제대로 읽어보자

  - 


---

### 💁🏼‍♂️가장 기억에 남는 교육 내용

- 

---

### 💫부족한 부분과 개선방향

- 순열과 조합, 완전 검색 다시 공부하기
  - 어떤 때에 순열과 조합이 적용되는지 문제들을 풀어보면서 파악하기
  - 브루트포스 .. 파워포스... 포스... 여튼 공부하기
