# 220214

### 👨🏼‍🏫과정 후기와 느낀점

- 2차 리스트 배열

  - 1차원 리스트를 묶어놓은 리스트

  - 2차원 이상의 다차원 리스트는 차원에 따라서 인덱스를 선언한다.

  - 2차원 리스트의 선언 : 세로길이(행), 가로길이(열)를 필요로 한다.

    - ```python
      arr = [[0,1,2,3],[4,5,6,7]] # 2행 4열의 2차원 리스트
      ```

  - 2차원 리스트 받는 법 / 돌리는법

    - ```python
      arr = [list(map(int, input().split())) for _ in range(N)] #요소가 공백으로 나뉘어져 있는 리스트
      
      arr = [list(map(int, input())) for _ in range(N)] # 요소가 붙여져있는 리스트 공백이 없는 경우
      ```

  - 배열 순회 : n x m 배열의 n*m개의 모든 원소를 빠짐없이 조사하는 방법

  - 행/열우선 순회 

    - 이중 포문

    - ```python
      for i in range(N):
          for j in range(M):
              array[i][j] : 행 우선
              array[j][i] : 열 우선
      ```

  - 지그재그 순회

    - i행과 j열의 좌표를 잘 활용

    - ```python
      for i in range(n):
          for j in range(m):
              array[i][j + (m-1-2j)*(i%2)] # j는 항상 0, 1, 2, 3.. 이런식으로 왔다갔다하는 것이 고정이므로 
      ```

    - 3*3 배열이 있다고 치자

    - ```python
      [000] # ==> for j(첫째 행에서는 정방향대로 조회) : 0 -> m-1
      [000] # <== for j (둘째 행에서는 반대로 조회): m-1 -> 0 
      [000] # ==> for j(셋째 행에서는 정방향대로 조회) : 0 -> m-1
      ```

- 델타 

  - 좌표에서 상하좌우로 움직일 수 있는 법!

  - 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법이다.

  - ```python
    arr[0...N-1][0...N-1]  # N*N 배열
    di = [0, 0, -1, 1]  # di와 dj 함께 움직이는 것이므로 (0,-1) (0, 1).. 이런식으로 볼 수 있고, 이는 좌우상하의 방
    dj = [-1, 1, 0, 0]  # 향이다. 내가 원하는대로 방향을 설정할 수 있다.
    
    for i in range(1, N-1):
        for j in range(1, N-1):
            for k in range(4):  # 상하좌우 4개이기 때문에
                ni = i + di[k]
                nj = j + dj[k]
                if 0 <= ni < N and 0 <= nj < N: #ni와 nj(이동후의 위치값)이 주어진 배열 칸에서 벗어나지 않으면
                    test(arr[ni][nj])
    ```

  - 90도씩 꺾어서 정답을 입력 또는 찾아야 하는 경우에 유용하다.

  - 리스트 내 튜플을 사용해서도 사용이 가능하다.

    - ```python
      for di, dj in [(0,1), (1,0), (0,-1), (-1,0)]: # 우하좌상
      	ni = i + di
          nj = j + dj
          if 0 <= ni < N and 0 <= nj < N:
                test(arr[ni][nj])
      ```

- 전치 행렬

  - 대각선 기준으로 마주보는 애들끼리 자리를 바꾸는 것
  - 모든 원소들에 대한 것이 아니라 대각선 지정 위 또는 아래 중 한 지역을 선택해주면 됨
  - 양쪽을 기준으로 하면 두번 바뀌게 되는것이라 원래 자리가 되므로 꼭 한 쪽을 지정
  - 대각선은 [i]==[j] 임

- 부분 집합

  - N개의 원소가 있을 때 공집합을 포함한 부분집합의 수는 2^N개 이다.
  - 원소가 {1, 2, 3, 4, 5}개면 32개의 부분집합 
  - 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우

- 비트연산자

  - & : 비트 단위로 and 연산을 한다. (둘 다 1이어야 됨)

    - i & (1<<j) : i의 j번째 비트가 1인지 아닌지를 검사한다.

  - | : 비트 단위로 or 연산을 한다. (둘 중 하나만 1이면 됨)

  - << : 피연산자의 비트 열을 왼쪽으로 이동시킨다. 즉 << 방향으로 1을 이동시키면서 밀어버림. 그리고 공백에는 0을 채워넣음

    - 1<<n  인 경우에는 1을 8비트의 n번째 칸으로 밀어버린다. 만약 5인 경우 0 0 1 0 0 0 0 0 이 되므로 이를 2진법 계산하여 2의 5승인 32가 된다.

  - `>>`: 피연산자의 비트 열을 오른쪽으로 이동시킨다.

  - 간결한 부분집합 생성시에 활용할 수 있다.

    - ```python
      arr = [3,6,7,1,5,4]
      n = len(arr)  # 원소의 개수 6
      for i in range(1<<n): # 2의 6승인 64개의 부분집합
          for j in range(n): # 6개의 비트를 비교함
              if i & (1<<j): # i의 j번 비트가 1인 경우에
                  print(arr[j], end= ", ") # j번 원소를 출력한다.
          print()
      print()
      ```

- 검색 

  - 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업

  - 탐색 키 (search key): 자료를 구별하여 인식할 수 있는 키

  - 검색 종류

    - 순차 검색 (sequential)
    - 이진 검색 (binary)
    - 해쉬 (hash)

  - 순차 검색

    - 일렬로 되어 있는 자료를 순서대로 검색하는 방법으로 원하는 항목을 찾을 때 유용함

    - 구현이 쉽지만 검색 대상 수가 많은 경우에는 수행시간이 급격히 증가하기 때문에 비효율적임

    - 2 가지 경우 : 정렬되어 있는 경우 VS  정렬이 안되어 있는 경우

    - 정렬이 안되어 있는 경우의 과정

      - 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다.

      - 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환

      - 자료구조의 마지막에 이를 때까지 검색 대상을 찾지 못하면 검색 실패

      - 찾고자 하는 원소의 순서에 따라 비교회수가 결정됨

      - 첫 번째 원소를 찾을 때는 1번 비교, 두 번째 원소를 찾을 때는 2번 비교

      - 정렬되지 않은 자료에서의 순차 검색의 평균 비교 회수

      - 시간 복잡도 O(n)

      - ```python
        def sequentialSearch(a, n, key): # a 찾고자 하는 리스트, n = a의 개수, key 찾고자 하는 수
            i = 0
        while i < n and a [i] != key:  # i < n 을 하는 이유는 인덱스 범위를 안쓰면 마지막에 범위를 넘어버리는 경우가 있어서 인덱스 에러가 발생함
            i = i+1
            if i < n : return i
            else:
                return -1
        ```

    - 정렬이 되어 있는 경우의 과정

      - 자료가 오름차순으로 정렬된 상태에서 실시한다고 가정

      - 자료를 순차적으로 검색하면서 키 값을 비교하여 원소의 키 값이 검색 대상의 키 값보다 크면 찾는 원소가 없다는 것이므로, 더 이상 검색하지 않고 검색을 종료 // 10을 찾는데 11이 나오면 종료해버림

      - 정렬이 되어 있으므로 검색 실패를 반환하는 경우 평균 비교 횟수가 반으로 줄어든다.

      - 시간 복잡도 O(n)

      - ```python
        def sequentialSearch_2(a, n, key): #리스트 a , n = 리스트 a 개수, 찾을 값
        	i = 0
            while i < n and a[i] < key : 
                i = i+1
                if i < n and a[i] == key:
                    return i
                else:
                    return -1
        ```

  - 이진 검색

    - 중앙의 키값을 우선 비교 후 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방식

    - 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행함

    - 자료가 정렬된 상태여야 한다!!

    - 과정

      - 중앙에 있는 자료의 원소를 고른다.

      - 중앙 원소 값과 찾고자 하는 목표 값을 비교한다.

      - 목표 값이 중앙 원소의 값보다 작으면, 자료의 왼쪽의 절반에 대해서 새로 검색을 수행, 크다면 자료의 오른쪽 절반에서 새로 검색을 수행한다.

      - 위 과정을 찾을 때까지 반복

      - ```
        a= [1 2 3 4 5 6 7 8 9 10] 일때 7을 찾는다고 가정한다.
        리스트는 0부터 시작하기 때문에 0 + 10의인덱스 위치인 len(a)-1을 더한다. => 9 를 2로 나눈 몫 => 4
        a[4] 검색 : 5를 검색, 7은 5보다 크므로, 5의 아래의 수들인 1 2 3 4는 순회 안한다.
        4+1=5 / 9 > 14 //2 => a[7] : 8 검사
        8보다 작은 7이니까 9 10 을 제거
        5 + 8 => 13 //2 => a[6] : 7 => 7 찾았다.
        ```

      - 이진 검색을 사용할 땐 시작,종료점을 이용하여 검색을 반복 수행

      - 자료 삽입, 삭제가 발생한 경우 배열의 상태를 항상 다시 정렬 상태로 유지하는 작업이 필요

      - ```python
        def binarySearch(a, N, key): # a 리스트, N 리스트의 길이, key 찾는 값
            start = 0
            end = N-1
            while start <= end :
                middle = (start + end) // 2
                if a [middle] == key :  # 맞는 값을 찾았을 때
                    return true  
                elif a[middle] > key :  # 찾는 수가 중앙 지점보다 작을 때, 중간 우측을 버렸으므로 중간 -1
                    end = middle -1
                else:      # 반대의 경우. 큰 경우 세는 시작 지점을 중간의 다음으로 이동
                    start = middle + 1
            return false        # 검색 실패
        ```
  
    - 재귀 함수 이용
  
  - 선택 정렬 (Selection)
  
    - 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식으로 셀렉션 알고리즘을 전체에 적용한 것
  
    - 과정
  
      - 주어진 리스트 중에서 최소값을 찾는다.
      - 그 값의 리스트의 맨 앞에 위치한 값과 교환한다.
      - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.
      - 점점 정렬의 구간이 작아지며 (구간의 시작이 바뀌고 끝은 고정이 되므로), 오름차순으로 정렬된다.
  
    - 시간 복잡도 O(n^2)
  
    - ```python
      def selectionSort(a, N):
          for i in range(N-1):
              minIdx = i
              for j in range(i+1, N):
                  if a[minIdx] > a[j]:
                      minIdx = j
              a[i], a[minIdx] = a[minIdx], a[i]
      ```
  
  - 셀렉션 알고리즘
  
    - 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법을 셀렉션 알고리즘이라 한다.
  
    - 최소값, 최대값 혹은 중간값을 찾는 알고리즘을 의미하기도 한다.
  
    - 과정
  
      - 정렬 알고리즘을 이용하여 자료 정렬하기
  
      - 원하는 순서에 있는 원소 가져오기
  
      - 1번부터 k번째까지 작은 원소들을 찾아 배열의 앞쪽으로 이동시키고, 배열의 k번째를 반환한다.
  
      - k 가 비교적 작을 때 유용하며 시간 복잡도는 O(kn)
  
      - ```python
        def select(arr, k):
            for i in range(0, k):  # k-1 번까지 돌리는 것이기에
                minIndex = i
                for j in range (i+1, len(arr)):
                    if arr[minIndex] > arr[j]:
                        minIndex = j
                arr[i], arr[minIndex] = arr[minIndex], arr[i]
            return arr[k-1]
        ```
  
  - 이거 시험에 나오나?
  
    - 선택 정렬과 버블 정렬이 비슷하게 평균 시간 복잡도가 O(n^2) 이다.
    - 이 둘의 차이점을 서술할 수 있어야한다.


---

### 💁🏼‍♂️가장 기억에 남는 교육 내용

- 1209 sum
  - sum 풀 때 최댓값을 받을 변수 0을 하나 지정해서 각 행과 열과 대각선을 돌 때마다 최대 값을 비교해서 바꿔주면 된다!
  - 굳이 내 코드처럼 각 열마다 최대값을 뽑아서 리스트에 담아서 정렬해서 뽑을 필요 없이 행, 열, 대각선 각 비교가 끝날 때마다 최대 값을 아예 바꿔버려서 버블소트 부분을 지워도 될듯
- 연습문제 2
  - 비트 연산자... 도대체 무엇인가?
  - 싸피 교육에 대한 의문을 가지게 됨... 이거 초보자도 할 수 있는 것인가?
  - 좌절을 맛본 날 2.... 알고리즘 시작 이후 자살마렵다..
- 달팽이
  - 야제발...ㅠㅠ 요리가 아닌 이상 숫자같은거 싸지 마 ㅠㅠ



---

### 💫부족한 부분과 개선방향

- 델타

  - 수업을 들어도 어떤 소리인지 이해를 할 수 없음
  - 개념은 이해는 했는데 문제에 적용하면 어떻게 활용할 수 있을지 그리고 문제를 읽어서 이거는 델타를 이용해야겠음을 모름.. 그렇기에 많은 문제를 접해봐야 할 것 같다.
  
- 계획을 다 못달성하는 것

  - 내가 어디에서 시간을 활용해야 할 것인가? 
  - 어떤 부분에서 허투루 사용하는 시간이 있는지 잘 체크해서 그 부분을 줄이도록 노력하기

  
